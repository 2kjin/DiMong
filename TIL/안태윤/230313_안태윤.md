# docker with python & flask application


## Summary

1. 간단한 flask application을 작성
2. docker container에 flask app 배포

## A minimal application with Flask

### minimal app in Official guide

[https://flask.palletsprojects.com/en/2.2.x/quickstart/#a-minimal-application](https://flask.palletsprojects.com/en/2.2.x/quickstart/#a-minimal-application)

```python
# hello.py
 1| from flask import Flask
 2|
 3| app = Flask(__name__)
 4|
 5| print(__name__)
 6|
 7| @app.route("/")
 8| def hello_world():
 9|     return "<p>Hello, World!!!</p>"
10|
11| if __name__ == '__main__':
12|     app.run(host='0.0.0.0',port=8080)

```

- line 별 설명
    - 1: Flask 클래스를 import
    - 3: module attribute _ _ name_ _ 으로 Flask 인스턴스 생성
        - _ _ name_ _ : 해당 모듈 namespace 리턴
        - [https://docs.python.org/3.7/reference/import.html#__name__](https://docs.python.org/3.7/reference/import.html#__name__)
    - 5 : ‘route’ decorator를 사용해 어떤 URL로 들어왔을 때 함수를 실행시킬 건지 명시
        - [https://docs.python.org/3/glossary.html#term-decorator](https://docs.python.org/3/glossary.html#term-decorator)
    - 6-7 : 간단한 HTML 타입 응답을 하는 함수를 작성
    - 11-12 : 로컬 개발 환경에서 어플리케이션을 실행하는 코드
- test run
    
    ```bash
    python hello.py
    ```
    

## Build image

Build docker image to run python application

### write Dockerfile

```docker
 1| FROM python:3.7-alpine

 2| RUN apk update
 3| RUN apk add --no-cache \\
 4|         bash

 5| RUN apk add --update build-base python3-dev py-pip

 6| ENV LIBRARY_PATH=/lib:/usr/lib

 7| COPY . /app/server

 8| EXPOSE 8080

 9| WORKDIR /app/server

10| RUN pip install flask

11| ENTRYPOINT ["python","app.py"]
```

- line 1 : python:3.7-alpine 을 base image로 설정
    - alpine : docker hub 에서 공개된 이미지의 태그 중 alpine 이라는 게 포함된 것이 많다.
        - detail
            
            Q: What are differences between alpine and default docker image
            
            A: 답변을 요약하면 alpine 이 간소화된 os 이미지라고 보면된다.
            
            위에서 apk add bash 명령어로 bash 설치하는데  alpine에 bash 가 포함되어있지 않기 때문이다.
            
            기본적으로 용량에서 차이가 많이난다.
            
            당연하게도 alpine 이미지로 실행한 컨테이너가 리소스 소비가 적다고 한다.
            
- line 2~5 : python 어플리케이션 실행을 위한 패키지 설치
- line 6 : 컨테이너 내 환경 변수 설정 위함.
    - detail
        
        > The "ENV" command in a Dockerfile is used to set environment variables that can be used within the container at runtime. In this case, the LIBRARY_PATH environment variable is being set to include the paths "/lib" and "/usr/lib", which are commonly used directories for shared libraries in Unix-like systems.
        Setting the LIBRARY_PATH environment variable can be useful when building or running software that depends on specific libraries located in those directories. By setting this variable in the Dockerfile, the environment variable will be available to any processes running inside the container, which can help ensure that the necessary libraries are found and used correctly.
        > 
- line 7 : 현재 directory(docker build 명령을 실행한 위치) 의 모든 파일을 컨테이너 내 /app/server 위치에 복사
- line 8 : 컨테이너의 포트를 외부로 개방
- line 9 : 명령어 실행 위치를 /app/server 로 이동 (cd /app/server 한 것과 같다) 이후 command 실행을 해당 위치에서 실행한다. /app/server로 소스를 복사했으니 해당 디렉토리로 이동후 남은 명령을 실행한다.
- line 10 : flask 모듈을 설치
    - pip install -r requirements.txt 명령어로 대체 가능
        - : 설치해야 할 패키지가 많을 때엔 requirement.txt 파일을 만들어서 관리할 수 있다.
- line 11 : ENTRYPOIN 는 해당 이미지로 컨테이너 실행시 명령어를 필수로 실행하도록 한다.
    - 명령어를 실행하는 지시어로 CMD 가 있는데 차이점은 CMD는 docker run 명령어 마지막에 전달되는 command parameter 로 대체 될 수 있다.

### build Docker image

- run command
    
    ```bash
    docker build -t <image-name> .
    ```
    
- Trouble shooting
    - pip install error
        - 에러 메세지
            
            ```bash
            WARNING: Retrying (Retry(total=0, connect=None, read=None, redirect=None, status=None)) after connection broken by 'NewConnectionError('<pip._vendor.urllib3.connection.HTTPSConnection object at 0x7ff967eb73a0>: Failed to establish a new connection: [Errno -3] Try again')': /simple/flask/
            ```
            
        - Dockerfile 안에 pip 로 flask module을 설치하는 부분이 있는데 해당 명령어 실행하는 단계에서 오류가 발생했다. DNS 문제일 수도 있다고 한다.
        - 해결
            - docker cotainer의 dns 기본 설정 추가 후 docker engine 재실행
                1. /etc/docker/daemon.json 파일 추가
                    
                    ```json
                    {
                    	"dns":["8.8.8.8"]
                    }
                    ```
                    
                2. docker engine 재실행
                    
                    ```bash
                    service docker restart
                    ```
                    
        - 참고
            - docker container 는 기본적으로 host OS의 dns 설정을 상속받는다.
            [https://docs.docker.com/config/containers/container-networking/#dns-services](https://docs.docker.com/config/containers/container-networking/#dns-services)
                - unbunt 20.04 기준 DNS 설정은 /etc/resolv.conf 에서 확인할 수 있다.
            - 질문
                - host OS 에서는 pip를 설치해도 정상적으로 작동하는데 왜 컨테이너에서는 안되는지 이해가 안됨. 어차피 host의 DNS 설정을 상속 받는다고 하는데.. 왜 안될까..
        
    

### run docker container with image

- run command
    
    ```bash
    docker run <image-name>
    ```
    

## run on Windows (local development enviroment)

Windows 개발 환경에서 같은 Dockerfile 

### build docker image

```bash
docker build -t <image-name> .
```

### run docker container with bind option

```bash
docker run -dp 8080:8080 --mount type=bind,src=%cd%,target=/app/server <image-name>
```

### change flask source and refresh browser